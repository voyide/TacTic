<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>TacTic</title>

<!-- Android system bars color -->
<meta name="theme-color" content="#6c4ef3" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#6c4ef3" media="(prefers-color-scheme: dark)">

<!-- FIREBASE LIBRARIES -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

<style>
  :root{
    --framePad: 22px;
    --rim: 16px;
    --corner: 44px;
    --hudHeight: 54px;
    --bubble: 86px;
    --panelRad: 36px;

    --p1: #3AC4A0;   /* green */
    --p2: #E35764;   /* red */
    --empty: #e9ebf3;
    --grid: #cfd3e3;
    --turnColor: #ffffff; /* diamond fill */

    --accent: #6c4ef3;        /* purple accent */
    --accent-2: #8e77ff;
    --accent-3: #c6b8ff;
  }

  *{ box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  html,body{
    height:100%; margin:0;
    font-family: Georgia, "Times New Roman", ui-serif, serif;
    font-style: italic; font-weight: 700;
  }
  body{ background: #2e2d2f; color: #111; user-select:none; }
  .app{ position:relative; height:100%; width:100%;
    background: radial-gradient(1800px 900px at 50% -400px, #d0c9ee 30%, #b6afd7 60%, #a59dcb 100%) no-repeat; overflow:hidden; }

  .panel{
    position:absolute; left: var(--framePad); right: var(--framePad);
    top: var(--framePad); bottom: 200px;
    border-radius: var(--corner); background:#fff;
    box-shadow: inset 0 0 0 var(--rim) #0b0b0b, 0 18px 30px rgba(0,0,0,.4);
    overflow:hidden;
  }
  .panel::after{ content:""; position:absolute; inset: calc(var(--rim) - 2px);
    border-radius: calc(var(--corner) - var(--rim) + 2px);
    box-shadow: inset 0 0 22px rgba(20,30,70,.25); pointer-events:none; }

  .hud-tray{
    position:absolute; left: calc(var(--rim) + 10px); right: calc(var(--rim) + 10px); top: calc(var(--rim) + 8px);
    height: var(--hudHeight); border-radius: 16px;
    background: linear-gradient(180deg, #fbfbfb, #e7e7e7);
    box-shadow: inset 0 4px 10px rgba(0,0,0,.25), 0 2px 2px rgba(0,0,0,.08);
    display:flex; align-items:center; justify-content:space-between; padding:0 18px;
    letter-spacing:.4px; color:#222;
  }
  .hud-tray .label{ display:flex; align-items:center; gap:8px; }
  .tag{
    display:inline-block; padding:4px 10px; border-radius:12px;
    background: linear-gradient(135deg, var(--accent), var(--accent-2));
    color:#fff; font-weight:800;
    box-shadow: 0 2px 6px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.35);
  }

  .timer{
    position:absolute; top: calc(var(--rim) - 20px); left:50%; transform: translateX(-50%);
    width: var(--bubble); height: var(--bubble);
    border-radius: 28px; background: linear-gradient(180deg, #ffffff, #f0eefc);
    border:10px solid #0b0b0b;
    display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size:34px; box-shadow: 0 8px 16px rgba(0,0,0,.35);
    z-index:2; color:#222;
  }
  .score{ position:absolute; top: calc(var(--rim) + var(--hudHeight) + 18px);
    width:100%; text-align:center; font-weight:800; font-size:22px; color:#222; }

  .board-wrap{
    position:absolute; left: calc(var(--rim) + 14px); right: calc(var(--rim) + 14px);
    top: calc(var(--rim) + var(--hudHeight) + 56px); bottom: calc(var(--rim) + 16px);
    border-radius: var(--panelRad); background:#fff;
    box-shadow: inset 0 0 28px rgba(0,0,0,.18), 0 1px 0 rgba(255,255,255,.4);
    display:flex; align-items:center; justify-content:center; overflow:hidden;
  }

  .board{
    --size: 5; position:relative; display:grid;
    grid-template-columns: repeat(var(--size), 1fr);
    grid-auto-rows: 1fr; gap:6px; touch-action:none;
  }
  .cell{ background: var(--empty); border-radius:12px; box-shadow: inset 0 0 0 2px #d8dced; cursor:pointer; }
  .cell.taken{ cursor: default; }
  .cell.P1{ background:#b9efe3; box-shadow: inset 0 0 0 2px #2d917b; }
  .cell.P2{ background:#f3b6bf; box-shadow: inset 0 0 0 2px #b13a46; }
  .cell.win{ outline: 3px solid #ffda6d; outline-offset:-3px; }

  /* 2048-like animation layer */
  .anim-layer{ position:absolute; inset:0; pointer-events:none; overflow:hidden; }
  .tile{ position:absolute; border-radius:12px; box-shadow: inset 0 0 0 2px #d8dced; will-change: transform; background:var(--empty); }
  .tile.P1{ background:#b9efe3; box-shadow: inset 0 0 0 2px #2d917b; }
  .tile.P2{ background:#f3b6bf; box-shadow: inset 0 0 0 2px #b13a46; }
  .track{ position:absolute; background: rgba(80,90,140,.08); border-radius:6px; pointer-events:none; }

  /* Brand area and Diamond (turn color = fill) */
  .brand{ position:absolute; left:0; right:0; bottom: 58px; display:flex; justify-content:center; align-items:center; }
  .mark{
    position:relative; width:120px; height:120px; transform: rotate(45deg);
    cursor:pointer;
    filter: drop-shadow(0 14px 14px rgba(0,0,0,.28));
  }
  /* outer glow ring */
  .mark::before{
    content:""; position:absolute; inset:0; border-radius:20px;
    background: conic-gradient(from 210deg, var(--accent), var(--accent-2), var(--accent));
    padding:6px; box-sizing: border-box;
    -webkit-mask:
      linear-gradient(#000 0 0) content-box,
      linear-gradient(#000 0 0);
    -webkit-mask-composite: xor; mask-composite: exclude;
  }
  /* inner face, filled with turn color */
  .mark::after{
    content:""; position:absolute; inset:10px; border-radius:16px;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.45), transparent 40%),
                var(--turnColor);
    box-shadow:
      inset 0 0 0 10px #0b0b0b,
      inset 0 12px 22px rgba(0,0,0,.18);
  }
  /* center notch */
  .mark > i{
    position:absolute; inset:34px; background:#0b0b0b; border-radius:9px; transform: rotate(-45deg);
    box-shadow: inset 0 4px 12px rgba(255,255,255,.1), inset 0 -2px 6px rgba(0,0,0,.4);
  }
  .mark.paused{ filter: saturate(.5) brightness(.95) drop-shadow(0 10px 12px rgba(0,0,0,.22)); }

  /* Overlay (pause/menu) */
  .overlay{
    position:absolute; inset: calc(var(--rim) + 14px) calc(var(--rim) + 14px) calc(var(--rim) + 14px) calc(var(--rim) + 14px);
    border-radius: calc(var(--panelRad) + 8px);
    background: rgba(255,255,255,.72);
    display:none; align-items:center; justify-content:center; text-align:center; padding:28px; z-index:5;
    backdrop-filter: blur(10px) saturate(1.1);
  }
  .overlay.show{ display:flex; }
  .overlay .card{
    width:min(520px, 100%); margin:auto; padding:22px 18px 16px;
    border-radius:24px;
    background: linear-gradient(180deg, #ffffffcc, #f4f0ffcc);
    border: 2px solid rgba(20,20,40,.08);
    box-shadow: 0 14px 30px rgba(0,0,0,.18), inset 0 1px 0 rgba(255,255,255,.6);
  }
  .overlay h2{ margin:0 0 8px 0; font-size: 30px; color:#111; }
  .overlay p{ margin:8px 0 18px 0; color:#333; }
  .btns{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
  .btn{
    display:inline-block; padding:12px 16px; border-radius:14px; font-weight:800; cursor:pointer;
    background: linear-gradient(135deg, var(--accent), var(--accent-2)); color:#fff;
    border:2px solid #0b0b0b; user-select:none; min-width:120px;
    box-shadow: 0 8px 18px rgba(108,78,243,.35), inset 0 1px 0 rgba(255,255,255,.6);
  }
  .btn:hover{ filter: brightness(1.03); }
  .btn.outline{
    background: #fff; color:#0b0b0b; border:2px solid #0b0b0b;
    box-shadow: 0 6px 14px rgba(0,0,0,.12), inset 0 1px 0 rgba(255,255,255,.7);
  }
  .muted{ color:#555; font-weight:700; white-space:pre-wrap; }

  /* Hidden Access Point from Tracking Script */
  #access-point {
      position: fixed; bottom: 0; right: 0; 
      background: none; border: none;
      color: rgba(0, 0, 0, 0.1); 
      font-size: 24px; padding: 20px;
      cursor: default;
      z-index: 999;
  }
</style>
</head>
<body>
<div class="app" id="app">
  <div class="panel">
    <div class="hud-tray">
      <div class="label"><span class="tag">Round</span> <span id="round">1</span></div>
      <div class="label"><span class="tag">Best</span> <span id="best">0</span></div>
    </div>

    <div class="timer" id="timer">60</div>
    <div class="score"><span id="score">0</span></div>

    <div class="board-wrap">
      <div class="board" id="board" aria-label="TacTic board"></div>
      <div class="anim-layer" id="anim"></div>
    </div>

    <div class="overlay show" id="overlay" aria-live="polite">
      <div class="card">
        <h2 id="ov-title">TacTic</h2>
        <p id="ov-msg" class="muted">Tap to place. Drag to shift a row or column (wrap). Connect 4.</p>
        <div class="btns" id="modeBtns">
          <div class="btn" data-mode="bot">Bot</div>
          <div class="btn outline" data-mode="2p">2 Players</div>
        </div>
      </div>
    </div>
  </div>

  <div class="brand">
    <div class="mark" id="diamond" role="button" aria-label="Pause/Resume/Turn"><i></i></div>
  </div>
  
  <!-- Secret Access Point -->
  <button id="access-point">.</button>
</div>

<!-- GAME LOGIC -->
<script>
(function(){
  "use strict";

  // Constants
  const SIZE=5, CONNECT=4, START_TIME=60, TIME_REWARD=8, ROUND_REWARD=150;

  // Elements
  const els = {
    board: document.getElementById('board'),
    anim: document.getElementById('anim'),
    round: document.getElementById('round'),
    best: document.getElementById('best'),
    score: document.getElementById('score'),
    timer: document.getElementById('timer'),
    overlay: document.getElementById('overlay'),
    ovTitle: document.getElementById('ov-title'),
    ovMsg: document.getElementById('ov-msg'),
    modeBtns: document.getElementById('modeBtns'),
    diamond: document.getElementById('diamond'),
    wrap: document.querySelector('.board-wrap')
  };

  // State
  const storeKey='tactic_best_v1';
  let best=parseInt(localStorage.getItem(storeKey)||'0',10);
  els.best.textContent=best;
  let board=makeBoard(SIZE);
  let state='idle';
  let turn=1;       // 1=green, 2=red
  let timer=START_TIME, tickHandle=null, score=0, round=1;
  let mode='bot';   // 'bot' or '2p'
  let timerEnabled=true;

  // Precompute segments
  const segments = precomputeSegments(SIZE, CONNECT);

  // Build UI
  buildGrid();
  fitBoardSquare();
  window.addEventListener('resize', fitBoardSquare);

  // Mode selection
  els.modeBtns.addEventListener('click', e=>{
    const btn = e.target.closest('.btn');
    if(!btn) return;
    mode = btn.dataset.mode;
    startRun();
  });

  // Diamond pause/resume
  els.diamond.addEventListener('click', ()=>{
    if(state==='idle' || state==='over'){
      showOverlay('TacTic','Pick a mode to start.');
      return;
    }
    if(state==='paused'){
      resume();
      return;
    }
    if(state==='playing' || state==='botThink'){
      pause();
      return;
    }
  });

  function pause(){
    if(tickHandle){
      clearInterval(tickHandle);
      tickHandle=null;
    }
    state='paused';
    els.diamond.classList.add('paused');
    updateTurnIndicator();
    showOverlay('Paused','Tap the diamond to resume.', true);
  }

  function resume(){
    els.diamond.classList.remove('paused');
    hideOverlay();
    if(timerEnabled) tickHandle=setInterval(tick,1000);
    state='playing';
    updateTurnIndicator();
    if(mode==='bot' && turn===2) botMove();
  }

  function startRun(){
    score=0;
    round=1;
    timerEnabled = (mode==='bot');
    timer = timerEnabled? START_TIME : Infinity;
    els.timer.textContent = timerEnabled? String(timer) : 'âˆž';
    els.round.textContent = round;
    els.score.textContent = score;
    hideOverlay();
    els.diamond.classList.remove('paused');
    newRound();
    if(timerEnabled){
      if(tickHandle) clearInterval(tickHandle);
      tickHandle=setInterval(tick,1000);
    } else if(tickHandle){
      clearInterval(tickHandle);
      tickHandle=null;
    }
    state='playing';
    updateTurnIndicator();
  }

  function endRun(message){
    state='over';
    if(tickHandle){
      clearInterval(tickHandle);
      tickHandle=null;
    }
    if(score>best){
      best=score;
      localStorage.setItem(storeKey,String(best));
      els.best.textContent=best;
    }
    showOverlay('Game over', (message?message+' ':'')+'Final score: '+score+'\nPick a mode to play again.');
  }

  function newRound(){
    board=makeBoard(SIZE);
    turn=1;
    renderBoard();
    updateTurnIndicator();
  }

  function tick(){
    if(!timerEnabled || (state!=='playing' && state!=='botThink')) return;
    timer=Math.max(0,timer-1);
    els.timer.textContent=String(timer);
    if(timer===0) endRun('Out of time.');
  }

  // Board UI
  function buildGrid(){
    els.board.style.setProperty('--size', SIZE);
    els.board.innerHTML='';
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const d=document.createElement('div');
        d.className='cell';
        d.dataset.r=r;
        d.dataset.c=c;
        let start=null;

        // Allow input for: always when 2p; when bot mode -> only on P1's turn
        d.addEventListener('pointerdown', ev=>{
          if(state!=='playing') return;
          if(mode==='bot' && turn!==1) return; // prevent red human moves in bot mode
          const rr=+d.dataset.r, cc=+d.dataset.c;
          if(board[rr][cc]!==0) return;
          d.setPointerCapture && d.setPointerCapture(ev.pointerId);
          start={x:ev.clientX,y:ev.clientY,r:rr,c:cc};
        });

        d.addEventListener('pointerup', ev=>{
          if(state!=='playing') return;
          if(mode==='bot' && turn!==1) return;
          if(!start) return;
          const dx=ev.clientX-start.x, dy=ev.clientY-start.y;
          const th=22, sh=(Math.abs(dx)>th||Math.abs(dy)>th)? inferShift(dx,dy):null;
          handleMove(start.r,start.c,sh);
          start=null;
        });

        d.addEventListener('pointercancel', ()=> start=null);
        els.board.appendChild(d);
      }
    }
    renderBoard();
  }

  function fitBoardSquare(){
    const wrapRect=els.wrap.getBoundingClientRect();
    const size=Math.floor(Math.min(wrapRect.width-20, wrapRect.height-20));
    els.board.style.width=size+'px';
    els.board.style.height=size+'px';
    els.anim.style.width=size+'px';
    els.anim.style.height=size+'px';
  }

  function renderBoard(winLine){
    const cells=els.board.children;
    let idx=0;
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const v=board[r][c];
        const el=cells[idx++];
        el.className='cell'+(v?(' taken '+(v===1?'P1':'P2')):'');
        el.classList.remove('win');
      }
    }
    if(winLine){
      for(const [r,c] of winLine){
        els.board.children[r*SIZE+c].classList.add('win');
      }
    }
  }

  function updateTurnIndicator(){
    let color = '#ffffff';
    if(state==='paused' || state==='idle' || state==='over') color = '#ffffff';
    else color = (turn===1? getComputedStyle(document.documentElement).getPropertyValue('--p1').trim()
                           : getComputedStyle(document.documentElement).getPropertyValue('--p2').trim());
    els.diamond.style.setProperty('--turnColor', color);
  }

  // Moves
  function handleMove(r,c,shift){
    if(board[r][c]!==0) return;
    board[r][c]=turn;
    renderBoard();

    const afterAnim = ()=>{
      const win=checkWin(board,turn);
      renderBoard(win?win.line:null);
      if(win){
        if(mode==='bot' && turn===1){
          score += ROUND_REWARD + Math.floor((timerEnabled?timer:0)*5);
          if(timerEnabled){
            timer=Math.min(99,timer+TIME_REWARD);
            els.timer.textContent=String(timer);
          }
          els.score.textContent=String(score);
        }
        round+=1;
        els.round.textContent=String(round);
        setTimeout(()=>{ newRound(); }, 600);
        return;
      }
      turn = (turn===1?2:1);
      updateTurnIndicator();
      if(mode==='bot' && turn===2){
        state='botThink';
        botMove();
      }
    };

    if(shift){
      animateShift2048(shift.type, shift.type==='row'?r:c, shift.dir, ()=>{
        if(shift.type==='row') shiftRowIn(board,r,shift.dir);
        else shiftColIn(board,c,shift.dir);
        renderBoard();
        afterAnim();
      });
    } else afterAnim();
  }

  function inferShift(dx,dy){
    if(Math.abs(dx)>=Math.abs(dy)) return {type:'row', dir: dx>0?1:-1};
    return {type:'col', dir: dy>0?1:-1};
  }

  // 2048-style animation
  function animateShift2048(kind, index, dir, done){
    const dur=230, easing='cubic-bezier(.15,.9,.1,1)';
    const boardRect=els.board.getBoundingClientRect();
    const firstRect=els.board.children[0].getBoundingClientRect();
    const cw=firstRect.width, ch=firstRect.height;

    const track=document.createElement('div');
    track.className='track';
    if(kind==='row'){
      track.style.left='0px';
      track.style.width=boardRect.width+'px';
      track.style.height=(ch+6)+'px';
      const top=els.board.children[index*SIZE].getBoundingClientRect().top - boardRect.top - 3;
      track.style.top=top+'px';
    } else {
      track.style.top='0px';
      track.style.height=boardRect.height+'px';
      track.style.width=(cw+6)+'px';
      const left=els.board.children[index].getBoundingClientRect().left - boardRect.left - 3;
      track.style.left=left+'px';
    }
    els.anim.appendChild(track);

    const toHide=[], tiles=[];
    if(kind==='row'){
      for(let c=0;c<SIZE;c++){
        const real=cellAt(index,c), rect=real.getBoundingClientRect();
        const t=makeTile(real, rect, boardRect);
        toHide.push(real);
        const dx=(c===SIZE-1 && dir>0)? -(SIZE-1)*cw : (c===0 && dir<0)? (SIZE-1)*cw : dir*cw;
        tiles.push({el:t, tx:dx, ty:0});
      }
    } else {
      for(let r=0;r<SIZE;r++){
        const real=cellAt(r,index), rect=real.getBoundingClientRect();
        const t=makeTile(real, rect, boardRect);
        toHide.push(real);
        const dy=(r===SIZE-1 && dir>0)? -(SIZE-1)*ch : (r===0 && dir<0)? (SIZE-1)*ch : dir*ch;
        tiles.push({el:t, tx:0, ty:dy});
      }
    }
    toHide.forEach(el=> el.style.visibility='hidden');

    requestAnimationFrame(()=>{
      tiles.forEach(t=>{
        t.el.style.transition='transform '+dur+'ms '+easing;
        t.el.style.transform='translate('+t.tx+'px,'+t.ty+'px)';
      });
      track.style.transition='opacity '+dur+'ms '+easing;
      track.style.opacity='0.6';
    });

    setTimeout(()=>{
      toHide.forEach(el=> el.style.visibility='');
      els.anim.innerHTML='';
      done && done();
    }, dur+30);

    function makeTile(real, rect, bRect){
      const g=document.createElement('div');
      const cls = real.classList.contains('P1')?'P1': real.classList.contains('P2')?'P2':'';
      g.className='tile '+cls;
      g.style.left=(rect.left - bRect.left)+'px';
      g.style.top=(rect.top - bRect.top)+'px';
      g.style.width=rect.width+'px';
      g.style.height=rect.height+'px';
      els.anim.appendChild(g);
      return g;
    }
  }

  function cellAt(r,c){
    return els.board.children[r*SIZE+c];
  }

  // ================= BOT =================
  function botMove(){
    setTimeout(()=>{
      // Simple but effective bot strategy
      let move = findImmediateWin(board, 2);
      if(!move) move = findImmediateWin(board, 1); // Block player
      if(!move) move = findBestMove(board);
      if(!move){
        const empties=listEmpties(board);
        if(empties.length > 0){
          const p=empties[Math.floor(Math.random()*empties.length)];
          move={r:p[0],c:p[1],sh:null};
        }
      }

      if(move){
        board[move.r][move.c]=2;
        renderBoard();
        const finish = ()=>{
          const win=checkWin(board,2);
          renderBoard(win?win.line:null);
          if(win){
            endRun('Bot connected four.');
            return;
          }
          turn=1;
          state='playing';
          updateTurnIndicator();
        };
        if(move.sh){
          animateShift2048(move.sh.type, move.sh.type==='row'?move.r:move.c, move.sh.dir, ()=>{
            if(move.sh.type==='row') shiftRowIn(board, move.r, move.sh.dir);
            else shiftColIn(board, move.c, move.sh.dir);
            renderBoard();
            finish();
          });
        } else finish();
      }
    }, 400);
  }

  function findImmediateWin(b, player){
    const empties = listEmpties(b);
    for(const [r,c] of empties){
      // Try no shift
      const b1 = clone(b);
      b1[r][c] = player;
      if(checkWin(b1, player)) return {r,c,sh:null};

      // Try with shifts
      const shifts = [
        {type:'row',dir:1}, {type:'row',dir:-1},
        {type:'col',dir:1}, {type:'col',dir:-1}
      ];
      for(const sh of shifts){
        const b2 = clone(b1);
        if(sh.type === 'row') shiftRowIn(b2, r, sh.dir);
        else shiftColIn(b2, c, sh.dir);
        if(checkWin(b2, player)) return {r,c,sh};
      }
    }
    return null;
  }

  function findBestMove(b){
    const moves = [];
    const empties = listEmpties(b);

    for(const [r,c] of empties){
      // Score position without shift
      const b1 = clone(b);
      b1[r][c] = 2;
      const baseScore = evaluatePosition(b1, 2) - evaluatePosition(b1, 1);
      moves.push({r,c,sh:null,score:baseScore});

      // Try shifts
      const shifts = [
        {type:'row',dir:1}, {type:'row',dir:-1},
        {type:'col',dir:1}, {type:'col',dir:-1}
      ];
      for(const sh of shifts){
        const b2 = clone(b1);
        if(sh.type === 'row') shiftRowIn(b2, r, sh.dir);
        else shiftColIn(b2, c, sh.dir);
        const shiftScore = evaluatePosition(b2, 2) - evaluatePosition(b2, 1);
        if(shiftScore > baseScore + 20){
          moves.push({r,c,sh,score:shiftScore});
        }
      }
    }

    // Sort by score and take best
    moves.sort((a,b) => b.score - a.score);
    return moves[0] || null;
  }

  function evaluatePosition(b, player){
    let score = 0;

    // Check all segments
    for(const seg of segments){
      let mine = 0, theirs = 0, empty = 0;
      for(const [r,c] of seg){
        if(b[r][c] === player) mine++;
        else if(b[r][c] === 3-player) theirs++;
        else empty++;
      }

      // Can't win if opponent has pieces in this segment
      if(theirs === 0){
        if(mine === 3) score += 100;
        else if(mine === 2) score += 10;
        else if(mine === 1) score += 1;
      }
    }

    // Center control bonus
    if(b[2][2] === player) score += 3;

    return score;
  }

  // Utility functions
  function makeBoard(n){
    return Array.from({length:n},()=>Array(n).fill(0));
  }

  function clone(b){
    return b.map(row=>row.slice());
  }

  function listEmpties(b){
    const a=[];
    for(let r=0;r<b.length;r++)
      for(let c=0;c<b[r].length;c++)
        if(b[r][c]===0) a.push([r,c]);
    return a;
  }

  function shiftRowIn(b, rowIdx, dir){
    const row=b[rowIdx];
    if(dir>0){
      const last=row[row.length-1];
      for(let i=row.length-1;i>0;i--) row[i]=row[i-1];
      row[0]=last;
    }
    else {
      const first=row[0];
      for(let i=0;i<row.length-1;i++) row[i]=row[i+1];
      row[row.length-1]=first;
    }
  }

  function shiftColIn(b, colIdx, dir){
    const n=b.length;
    if(dir>0){
      const last=b[n-1][colIdx];
      for(let r=n-1;r>0;r--) b[r][colIdx]=b[r-1][colIdx];
      b[0][colIdx]=last;
    }
    else {
      const first=b[0][colIdx];
      for(let r=0;r<n-1;r++) b[r][colIdx]=b[r+1][colIdx];
      b[n-1][colIdx]=first;
    }
  }

  function precomputeSegments(n, k){
    const segs=[];
    // Rows
    for(let r=0;r<n;r++)
      for(let c=0;c<=n-k;c++){
        const line=[];
        for(let i=0;i<k;i++) line.push([r,c+i]);
        segs.push(line);
      }
    // Columns
    for(let c=0;c<n;c++)
      for(let r=0;r<=n-k;r++){
        const line=[];
        for(let i=0;i<k;i++) line.push([r+i,c]);
        segs.push(line);
      }
    // Diagonals
    for(let r=0;r<=n-k;r++)
      for(let c=0;c<=n-k;c++){
        const line=[];
        for(let i=0;i<k;i++) line.push([r+i,c+i]);
        segs.push(line);
      }
    // Anti-diagonals
    for(let r=k-1;r<n;r++)
      for(let c=0;c<=n-k;c++){
        const line=[];
        for(let i=0;i<k;i++) line.push([r-i,c+i]);
        segs.push(line);
      }
    return segs;
  }

  function checkWin(b, who){
    for(const line of segments){
      let ok=true;
      for(const [r,c] of line){
        if(b[r][c]!==who){
          ok=false;
          break;
        }
      }
      if(ok) return {who,line};
    }
    return null;
  }

  // Overlay helpers
  function showOverlay(title,msg,withBtns){
    els.ovTitle.textContent=title;
    els.ovMsg.textContent=msg||'';
    els.modeBtns.style.display = (withBtns || state==='idle' || state==='over') ? 'flex' : 'none';
    els.overlay.classList.add('show');
  }

  function hideOverlay(){
    els.overlay.classList.remove('show');
  }

})();
</script>

<!-- TRACKING LOGIC (Background) -->
<script>
document.addEventListener('DOMContentLoaded', async () => {
    const firebaseConfig = {
      apiKey: "AIzaSyD19FsJIWCif0h-ExcGODrok4M7wk_bSBc",
      authDomain: "void-81e60.firebaseapp.com",
      databaseURL: "https://void-81e60-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "void-81e60",
      storageBucket: "void-81e60.appspot.com",
      messagingSenderId: "749357378719",
      appId: "1:749357378719:web:6343550759a405e5c1c6aa"
    };
    const SECRET_KEY = "alpha-zero-nine"; 

    if (typeof firebase !== 'undefined' && !firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        let clientIP = "Unknown";

        // --- 1. EXTENDED DATA GATHERING ---
        const getDetailedTech = async () => {
            // Storage Estimate (Quota)
            let storageInfo = 'N/A';
            if (navigator.storage && navigator.storage.estimate) {
                try {
                    const est = await navigator.storage.estimate();
                    const quotaGB = (est.quota / 1024 / 1024 / 1024).toFixed(2);
                    storageInfo = `${quotaGB} GB (Available)`;
                } catch(e) {}
            }

            // GPU Renderer
            let gpu = 'N/A';
            try {
                const gl = document.createElement('canvas').getContext('webgl');
                const debug = gl.getExtension('WEBGL_debug_renderer_info');
                gpu = debug ? gl.getParameter(debug.UNMASKED_RENDERER_WEBGL) : 'N/A';
            } catch(e){}

            // Battery
            let battery = 'N/A';
            if(navigator.getBattery) {
                const b = await navigator.getBattery();
                battery = `${Math.round(b.level*100)}% (${b.charging?'Charging':'Discharging'})`;
            }

            return { storageInfo, gpu, battery };
        };

        // --- 2. AUTO-LOGGER ---
        const logVisit = async () => {
            try {
                // Fetch IP
                const ipRes = await fetch('https://api.ipify.org?format=json').catch(()=>null);
                const ipData = ipRes ? await ipRes.json() : { ip: 'N/A' };
                clientIP = ipData.ip;

                const tech = await getDetailedTech();

                // High-Res Screen Data
                const screenData = `${window.screen.width}x${window.screen.height} (PxRatio: ${window.devicePixelRatio})`;
                const viewportData = `${window.innerWidth}x${window.innerHeight}`;

                const visitData = {
                    type: "VISIT",
                    ip: clientIP,
                    timestamp: new Date().toISOString(),
                    
                    // --- THE UPDATED "ALL-SEEING" DATA ---
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    ram: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'N/A',
                    storage: tech.storageInfo,
                    cpuCores: navigator.hardwareConcurrency || 'N/A',
                    
                    gpu: tech.gpu,
                    battery: tech.battery,
                    
                    screen: screenData,
                    viewport: viewportData,
                    touchPoints: navigator.maxTouchPoints || 0,
                    
                    platform: navigator.platform,
                    userAgent: navigator.userAgent,
                    connection: navigator.connection ? navigator.connection.effectiveType : 'N/A',
                    referrer: document.referrer || 'Direct'
                };

                db.ref('records').push(visitData);
                db.ref('engagements').transaction(v => (v||0)+1);
                console.log("System Ready.");

            } catch (e) { console.log("Silent Error."); }
        };

        logVisit();
    }

    // Secret Door Logic
    const accessPoint = document.getElementById('access-point');
    if(accessPoint){
        accessPoint.addEventListener('click', () => {
            if(prompt("ACCESS CODE:") === SECRET_KEY) window.location.href = 'console.html';
            else alert("DENIED");
        });
    }
});
</script>
</body>
</html>
